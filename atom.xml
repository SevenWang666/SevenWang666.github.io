<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xincheng</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-08T16:15:04.548Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xincheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mobx文档</title>
    <link href="http://example.com/2021/11/01/MobX%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2021/11/01/MobX%E6%96%87%E6%A1%A3/</id>
    <published>2021-11-01T00:00:00.000Z</published>
    <updated>2021-11-08T16:15:04.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MobX文档"><a href="#MobX文档" class="headerlink" title="MobX文档"></a>MobX文档</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ol><li><p><a href="https://cn.mobx.js.org/">mobx中文文档</a></p></li><li><p><a href="https://github.com/mobxjs/mobx">mobx源码地址</a></p></li><li><p><a href="https://mobx-react.js.org/">mobx-react-lite英文文档（暂时没有找到完整版的中文版文档）</a></p></li><li><p><a href="https://github.com/mobxjs/mobx-react">mobx-react源码地址</a>(下面的README.md里是完整版本的英文文档)</p></li><li><p><a href="https://github.com/mobxjs/mobx-react-lite">mobx-react-lite源码地址</a></p><p>​    </p></li></ol><h2 id="关于库"><a href="#关于库" class="headerlink" title="关于库"></a>关于库</h2><p><strong>mobx</strong>：提供observable、action、computed等API的库，类比redux。</p><p><strong>mobx-react</strong>：提供Provider、inject、observer、Observer、useObserver、useAsObservableSource、 useLocalStore等API的库。最新版的mobx-react中包括了mobx-react-lite。</p><p><strong>mobx-react-lite</strong>：相当于是mobx-react的精简版，不支持Provider、inject，但是用户可以依靠React Context自己实现这两个API的功能。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="MobX简介"><a href="#MobX简介" class="headerlink" title="MobX简介"></a>MobX简介</h3><p>简单、可扩展的状态管理。</p><p>安装 <code>yarn add mobx </code></p><p>React 绑定库: <code>yarn add mobx-react</code></p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><pre><code> MobX 可以通过 *decorate* 工具在不支持装饰器语法的情况加使用。 尽管如此，多数 MobX 用户更喜欢装饰器语法，因为它更简洁。</code></pre><p>装饰器参考<a href="https://cn.mobx.js.org/best/decorators.html">https://cn.mobx.js.org/best/decorators.html</a></p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>MobX通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展。MobX背后的哲学很简单:</p><p><em>任何源自应用状态的东西都应该自动地获得。</em></p><p>其中包括UI、数据序列化、服务器通讯，等等。</p><p><img src="https://cn.mobx.js.org/flow.png" alt="MobX unidirectional flow"></p><p>React 和 MobX 是一对强力组合。React 通过提供机制把应用状态转换为可渲染组件树并对其进行渲染。而MobX提供机制来存储和更新应用状态供 React 使用。</p><p>对于应用开发中的常见问题，React 和 MobX 都提供了最优和独特的解决方案。React 提供了优化UI渲染的机制， 这种机制就是通过使用虚拟DOM来减少昂贵的DOM变化的数量。MobX 提供了优化应用状态与 React 组件同步的机制，这种机制就是使用响应式虚拟依赖状态图表，它只有在真正需要的时候才更新并且永远保持是最新的。</p><h3 id="lesson1-MobX要点"><a href="#lesson1-MobX要点" class="headerlink" title="lesson1-MobX要点"></a>lesson1-MobX要点</h3><h4 id="1-定义状态并使其可观察"><a href="#1-定义状态并使其可观察" class="headerlink" title="1. 定义状态并使其可观察"></a>1. 定义状态并使其可观察</h4><p>可以用任何你喜欢的数据结构来存储状态，如对象、数组、类。 循环数据结构、引用，都没有关系。 只要确保所有会随时间流逝而改变的属性打上 <code>mobx</code> 的标记使它们变得可观察即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable&#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> appState = observable(&#123;</span><br><span class="line">    <span class="attr">timer</span>: <span class="number">0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="2-创建视图以响应状态的变化"><a href="#2-创建视图以响应状态的变化" class="headerlink" title="2. 创建视图以响应状态的变化"></a>2. 创建视图以响应状态的变化</h4><p>我们的 <code>appState</code> 还没有观察到任何的东西。 你可以创建视图，当 <code>appState</code> 中相关数据发生改变时视图会自动更新。 MobX 会以一种最小限度的方式来更新视图。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;observer&#125; <span class="keyword">from</span> <span class="string">&quot;mobx-react&quot;</span>;</span><br><span class="line"></span><br><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  onReset = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.appState.resetTimer();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onReset&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        Seconds passed: &#123;this.props.appState.timer&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TimerView;</span><br></pre></td></tr></table></figure><h4 id="3-更改状态"><a href="#3-更改状态" class="headerlink" title="3. 更改状态"></a>3. 更改状态</h4><p>第三件要做的事就是更改状态。 也就是你的应用究竟要做什么。 不像一些其它框架，MobX 不会命令你如何如何去做。 这是最佳实践，但关键要记住一点: <strong>MobX 帮助你以一种简单直观的方式来完成工作</strong>。</p><p>下面的代码每秒都会修改你的数据，而当需要的时候UI会自动更新。 无论是在<strong>改变</strong>状态的控制器函数中，还是在应该<strong>更新</strong>的视图中，都没有明确的关系定义。 使用 <code>observable</code> 来装饰你的<strong>状态</strong>和<strong>视图</strong>，这足以让 MobX检测所有关系了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">appState.resetTimer = action(<span class="function"><span class="keyword">function</span> <span class="title">reset</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    appState.timer = <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(action(<span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    appState.timer += <span class="number">1</span>;</span><br><span class="line">&#125;), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>只有在严格模式(默认是不启用)下使用 MobX 时才需要 <code>action</code> 包装。 建议使用 action，因为它将帮助你更好地组织应用，并表达出一个函数修改状态的意图。 同时,它还自动应用事务以获得最佳性能。</p><h3 id="lesson2-MobX-API-概念"><a href="#lesson2-MobX-API-概念" class="headerlink" title="lesson2-MobX API 概念"></a>lesson2-MobX API 概念</h3><h4 id="Observable-state-可观察的状态"><a href="#Observable-state-可观察的状态" class="headerlink" title="Observable state(可观察的状态)"></a>Observable state(可观察的状态)</h4><p>MobX 为现有的数据结构(如对象，数组和类实例)添加了可观察的功能。 通过使用 <a href="http://cn.mobx.js.org/refguide/observable-decorator.html">@observable</a> 装饰器(ES.Next)来给你的类属性添加注解就可以简单地完成这一切。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable, computed&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> </span>&#123;</span><br><span class="line">  @observable todos = [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&quot;0&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;任务0&quot;</span>, <span class="attr">finished</span>: <span class="literal">false</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="string">&quot;1&quot;</span>, <span class="attr">title</span>: <span class="string">&quot;任务1&quot;</span>, <span class="attr">finished</span>: <span class="literal">false</span>&#125;</span><br><span class="line">  ];</span><br><span class="line">  @computed <span class="keyword">get</span> <span class="title">unfinishedTodoCount</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.finished).length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Computed-values-计算值"><a href="#Computed-values-计算值" class="headerlink" title="Computed values(计算值)"></a>Computed values(计算值)</h4><p>定义在相关数据发生变化时自动更新的值。如上段代码，当添加了一个新的todo或者某个todo的 <code>finished</code> 属性发生变化时，MobX 会确保 <code>unfinishedTodoCount</code> 自动更新。</p><h4 id="Reactions-反应"><a href="#Reactions-反应" class="headerlink" title="Reactions(反应)"></a>Reactions(反应)</h4><p>Reactions 和计算值很像，但它不是产生一个新的值，而是会产生一些副作用，比如打印到控制台、网络请求、递增地更新 React 组件树以修补DOM、等等。</p><h5 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h5><p>如果你用 React 的话，可以把你的(无状态函数)组件变成响应式组件，方法是在组件上添加 <a href="http://cn.mobx.js.org/refguide/observable-decorator.html"><code>observer</code></a> 函数/ 装饰器. <code>observer</code>由 <code>mobx-react</code> 包提供的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observer&#125; <span class="keyword">from</span> <span class="string">&quot;mobx-react&quot;</span>;</span><br><span class="line"></span><br><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoListView</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;todos, unfinishedTodoCount&#125; = <span class="built_in">this</span>.props.todoList;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;todos.map(todo =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">TodoView</span> <span class="attr">todo</span>=<span class="string">&#123;todo&#125;</span> <span class="attr">key</span>=<span class="string">&#123;todo.id&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        Tasks left: &#123;unfinishedTodoCount&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TodoView = observer(<span class="function">(<span class="params">&#123;todo&#125;</span>) =&gt;</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">checked</span>=<span class="string">&#123;todo.finished&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> todo.finished = !todo.finished&#125;</span></span><br><span class="line"><span class="xml">        /&gt;&#123;todo.title&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> TodoList();</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">TodoListView</span> <span class="attr">todoList</span>=<span class="string">&#123;store&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="自定义-reactions"><a href="#自定义-reactions" class="headerlink" title="自定义 reactions"></a>自定义 reactions</h5><p>使用<a href="http://cn.mobx.js.org/refguide/autorun.html"><code>autorun</code></a>、<a href="http://cn.mobx.js.org/refguide/reaction.html"><code>reaction</code></a> 和 <a href="http://cn.mobx.js.org/refguide/when.html"><code>when</code></a> 函数即可简单的创建自定义 reactions，以满足你的具体场景。</p><p>例如，每当 <code>unfinishedTodoCount</code> 的数量发生变化时，下面的 <code>autorun</code> 会打印日志消息:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">autorun(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Tasks left: &quot;</span> + todos.unfinishedTodoCount)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="MobX-会对什么作出响应"><a href="#MobX-会对什么作出响应" class="headerlink" title="MobX 会对什么作出响应?"></a>MobX 会对什么作出响应?</h5><p><em>MobX 会对在执行跟踪函数期间读取的任何现有的可观察属性做出反应</em>。</p><h4 id="Actions-动作"><a href="#Actions-动作" class="headerlink" title="Actions(动作)"></a>Actions(动作)</h4><p>任何应用都有动作。动作是任何用来修改状态的东西。</p><p>使用MobX你可以在代码中显式地标记出动作所在的位置。 动作可以有助于更好的组织代码。 建议在任何更改 observable 或者有副作用的函数上使用动作。 结合开发者工具的话，动作还能提供非常有用的调试信息。 注意: 当启用<strong>严格模式</strong>时，需要强制使用 <code>action</code>，参见 <code>enforceActions</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;configure&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不允许在动作外部修改状态</span></span><br><span class="line">configure(&#123;<span class="attr">enforceActions</span>: <span class="string">&quot;observed&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="enforceActions"><a href="#enforceActions" class="headerlink" title="enforceActions"></a><code>enforceActions</code></h4><p>也被称为“严格模式”。</p><p>在严格模式下，不允许在 <a href="https://cn.mobx.js.org/refguide/action.html"><code>action</code></a> 外更改任何状态。 可接收的值:</p><ul><li><code>&quot;never&quot;</code> (默认): 可以在任意地方修改状态</li><li><code>&quot;observed&quot;</code>: 在某处观察到的所有状态都需要通过动作进行更改。在正式应用中推荐此严格模式。</li><li><code>&quot;always&quot;</code>: 状态始终需要通过动作来更新(实际上还包括创建)。</li></ul><h3 id="lesson3-给组件添加响应式"><a href="#lesson3-给组件添加响应式" class="headerlink" title="lesson3-给组件添加响应式"></a>lesson3-给组件添加响应式</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gijayj5424j30z80u07wh.jpg" alt="image-20200908160328366"></p><p>给组件添加响应式有以下三种办法：</p><p>😎 <a href="https://mobx-react.js.org/observer-hoc">observer HOC</a></p><p>🤓 <a href="https://mobx-react.js.org/observer-component">observer component</a></p><p>🧐 <a href="https://mobx-react.js.org/observer-hook">useObserver hook</a></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Observer, useObserver, observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span> <span class="comment">// 6.x or mobx-react-lite@1.4.0</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = observable(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// named function is optional (for debugging purposes)</span></span><br><span class="line"><span class="keyword">const</span> P1 = observer(<span class="function"><span class="keyword">function</span> <span class="title">P1</span>(<span class="params">&#123; person &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;person.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> P2 = <span class="function">(<span class="params">&#123; person &#125;</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Observer</span>&gt;</span>&#123;() =&gt; <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;person.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Observer</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> P3 = <span class="function">(<span class="params">&#123; person &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> useObserver(<span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;person.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">P1</span> <span class="attr">person</span>=<span class="string">&#123;person&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">P2</span> <span class="attr">person</span>=<span class="string">&#123;person&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">P3</span> <span class="attr">person</span>=<span class="string">&#123;person&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  person.name = <span class="string">&#x27;Jane&#x27;</span></span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h5 id="observer-HOC"><a href="#observer-HOC" class="headerlink" title="observer HOC"></a>observer HOC</h5><p>注意：mobx-react与mobx-react-lite中都有observer，但是后者不支持类组件。</p><p>以下是参数，如果组件是函数式组件，可以使用options，类组件则没有。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">observer&lt;P&gt;(baseComponent: React.FC&lt;P&gt;, options?: IObserverOptions): React.FC&lt;P&gt;</span><br><span class="line"></span><br><span class="line">interface IObserverOptions &#123;</span><br><span class="line">    // Pass true to use React.forwardRef over the inner component. It&#x27;s false by the default.</span><br><span class="line">    forwardRef?: boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>observer把组件转换成响应式组件，它可以自动追踪哪个可观察量被使用了以及当值改变的时候自动重新渲染这个组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observer, useLocalStore &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span> <span class="comment">// 6.x or mobx-react-lite@1.4.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Counter = observer&lt;Props&gt;(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> store = useLocalStore(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: props.initialCount,</span><br><span class="line">    <span class="function"><span class="title">inc</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      store.count += <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;store.count&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;store.inc&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>observer内部使用了React.memo，所以使用的时候我们可以不用自己再封装memo，但值得注意的是，observer内部封装的memo只负责默认的浅比较，因为mobx-react认为，observed组件很少需要基于复杂的props进行更新渲染。以下是mobx-react-lite中的源码部分截图，参考行61-63的注释。</p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gircs01emmj30ut0u0e81.jpg" alt="image-20200915151056480" style="zoom:50%;" /><h5 id="Observer-component"><a href="#Observer-component" class="headerlink" title="Observer component"></a>Observer component</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Observer&gt;&#123;renderFn&#125;&lt;/Observer&gt;</span><br></pre></td></tr></table></figure><p>接收一个匿名无参数的函数作为children，并且返回React元素。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Observer, useLocalStore &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span> <span class="comment">// 6.x or mobx-react-lite@1.4.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ObservePerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> person = useLocalStore(<span class="function">() =&gt;</span> (&#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;))</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;person.name&#125; <span class="tag">&lt;<span class="name">i</span>&gt;</span>I will never change my name<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Observer</span>&gt;</span>&#123;() =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;person.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Observer</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> (person.name = &#x27;Mike&#x27;)&#125;&gt;</span></span><br><span class="line"><span class="xml">          I want to be Mike</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：只能使得它自己的返回组件是响应式的，如果你里面还嵌套了别的组件，那这个里面的组件得靠自己变成响应式~</p><p>看下面的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span> <span class="comment">// 6.x or mobx-react-lite@1.4.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObservePerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Observer</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;() =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">GetStore</span>&gt;</span>&#123;store =&gt; <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;self&quot;</span>&gt;</span>&#123;store.wontSeeChangesToThis&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">GetStore</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Observer</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子里，这个className为div就不是响应式，如果想变成响应式，需要再额外添加，比如说像下面这样：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Observer &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span> <span class="comment">// 6.x or mobx-react-lite@1.4.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObservePerson</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">GetStore</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;store =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Observer</span>&gt;</span>&#123;() =&gt; <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;store.changesAreSeenAgain&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;<span class="tag">&lt;/<span class="name">Observer</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">GetStore</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="useObserver-hook"><a href="#useObserver-hook" class="headerlink" title="useObserver hook"></a>useObserver hook</h5><p>函数签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useObserver&lt;T&gt;(fn: () =&gt; T, baseComponentName = &quot;observed&quot;, options?: IUseObserverOptions): T</span><br><span class="line"></span><br><span class="line">interface IUseObserverOptions &#123;</span><br><span class="line">    // optional custom hook that should make a component re-render (or not) upon changes</span><br><span class="line">    useForceUpdate: () =&gt; () =&gt; void</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个自定义hook方法只存在于mobx-react-lite，或者是mobx-react@6。</p><p>这个hook方法也可以使组件变得响应式，但是关于一些优化兼容手段如memo或者forwardRef，则需要你自己手动添加。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useObserver, useLocalStore &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span> <span class="comment">// 6.x or mobx-react-lite@1.4.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> person = useLocalStore(<span class="function">() =&gt;</span> (&#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;))</span><br><span class="line">  <span class="keyword">return</span> useObserver(<span class="function">() =&gt;</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;person.name&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> (person.name = &#x27;Mike&#x27;)&#125;&gt;No! I am Mike<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有个优点，就是任何的hook改变observable，组件都不会重复渲染。</p><p>这个方法有个缺点，就是就算你是在组件的某一部分使用，但是却能引起组件的全部更新~，所以慎用，如果想要精细控制的话，还是要选择<Observer/>或者useForceUpdate。</p><h3 id="lesson4-Mange-state-状态管理"><a href="#lesson4-Mange-state-状态管理" class="headerlink" title="lesson4-Mange state-状态管理"></a>lesson4-Mange state-状态管理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useLocalStore&lt;T, S&gt;(initializer: () =&gt; T, source?: S): T</span><br></pre></td></tr></table></figure><p>本地的observable state可以使用useLocalStore，但是记住一点就是对于每个组件实例，useLocalStore的<strong>初始化函数只执行一次</strong>，并且是在组件的整个生命周期里都有效。</p><p>useLocalStore返回对象里的所有属性值都会自动转变为observable，所有getters会被转化为computed属性，所有方法也会与store关联且自动引用 mobx的transaction。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useLocalStore, useObserver &#125; <span class="keyword">from</span> <span class="string">&#x27;mobx-react&#x27;</span> <span class="comment">// 6.x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SmartTodo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> todo = useLocalStore(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;Click to toggle&#x27;</span>,</span><br><span class="line">    <span class="attr">done</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="function"><span class="title">toggle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      todo.done = !todo.done</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title">emoji</span>() &#123;</span><br><span class="line">      <span class="keyword">return</span> todo.done ? <span class="string">&#x27;😜&#x27;</span> : <span class="string">&#x27;🏃&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> useObserver(<span class="function">() =&gt;</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">onClick</span>=<span class="string">&#123;todo.toggle&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;todo.title&#125; &#123;todo.emoji&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="不要解构"><a href="#不要解构" class="headerlink" title="不要解构"></a>不要解构</h5><p>解构的话，会破坏响应式。mobx中的observables都是对象，一旦解构，所有的原始变量都会停留在上一个值，而不再是observable了。比如上面的例子中，你可以取值todo.title，但是不能const {title} = todo。</p><h5 id="关于全局store"><a href="#关于全局store" class="headerlink" title="关于全局store"></a>关于全局store</h5><p>虽然useLocalStore的命名听着像是只能用在组件内，但实际上，完全可以使用它再加上React Context来处理全局的store。</p><h3 id="lesson5-实现mobx-react-lite的useObserver"><a href="#lesson5-实现mobx-react-lite的useObserver" class="headerlink" title="lesson5-实现mobx-react-lite的useObserver"></a>lesson5-实现mobx-react-lite的useObserver</h3><p>useObserver简版实现代码如下，详细参考git-lesson5：<a href="https://github.com/bubucuo/React-Mobx/tree/lesson5">https://github.com/bubucuo/React-Mobx/tree/lesson5</a></p><h5 id="Reaction"><a href="#Reaction" class="headerlink" title="Reaction"></a>Reaction</h5><p>Reaction是一种的特殊的衍生（Derivation），可以注册响应函数，如强制组件更新的forceUpdate。常用于触发副作用，如打印日志、更新 DOM 或者发送网络请求等等。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useRef, useReducer, useEffect&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Reaction&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;useForceUpdate&#125; <span class="keyword">from</span> <span class="string">&quot;./utils&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observerComponentNameFor</span>(<span class="params">baseComponentName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`observer<span class="subst">$&#123;baseComponentName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useObserver</span>(<span class="params">fn, baseComponentName = <span class="string">&quot;observed&quot;</span>, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// const [, forceUpdate] = useReducer(x =&gt; x + 1, 0);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> wantedForceUpdateHook = options.useForceUpdate || useForceUpdate;</span><br><span class="line">  <span class="keyword">const</span> forceUpdate = wantedForceUpdateHook();</span><br><span class="line">  <span class="comment">// 组件有初次渲染和更新，那这个时候reaction得做一个缓存，</span></span><br><span class="line">  <span class="keyword">const</span> reactionTrackingRef = useRef(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!reactionTrackingRef.current) &#123;</span><br><span class="line">    reactionTrackingRef.current = &#123;</span><br><span class="line">      <span class="attr">reaction</span>: <span class="keyword">new</span> Reaction(</span><br><span class="line">        observerComponentNameFor(baseComponentName),</span><br><span class="line">        <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 响应函数使用forceUpdate</span></span><br><span class="line">          forceUpdate();</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123;reaction&#125; = reactionTrackingRef.current;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 清理reaction</span></span><br><span class="line">      reactionTrackingRef.current.reaction.dispose();</span><br><span class="line">      reactionTrackingRef.current = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> rendering;</span><br><span class="line"></span><br><span class="line">  reaction.track(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    rendering = fn();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> rendering;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="lesson6-实现mobx-react-lite的Observer与observer"><a href="#lesson6-实现mobx-react-lite的Observer与observer" class="headerlink" title="lesson6-实现mobx-react-lite的Observer与observer"></a>lesson6-实现mobx-react-lite的Observer与observer</h3><p>两者都是基于useObserver实现的。</p><p>首先是Observer Component，把children或者render作为useObserver的第一个参数作为函数返回即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useObserver&#125; <span class="keyword">from</span> <span class="string">&quot;./useObserver&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObserverComponent</span>(<span class="params">&#123;children, render&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> component = children || render;</span><br><span class="line">  <span class="keyword">return</span> useObserver(component);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;ObserverComponent <span class="keyword">as</span> Observer&#125;;</span><br></pre></td></tr></table></figure><p>mobx-react-lite的observer则是相当于在useObserver的基础上再封装了一层forwardRef和memo。</p><p>实现代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;memo, forwardRef&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;useObserver&#125; <span class="keyword">from</span> <span class="string">&quot;./useObserver&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">baseComponent, options = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> realOptions = &#123;</span><br><span class="line">    <span class="attr">forwardRef</span>: <span class="literal">false</span>,</span><br><span class="line">    ...options</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> useWrappedComponent = <span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> useObserver(<span class="function">() =&gt;</span> baseComponent(props, ref));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> memoComponent;</span><br><span class="line">  <span class="keyword">if</span> (realOptions.forwardRef) &#123;</span><br><span class="line">    memoComponent = memo(forwardRef(useWrappedComponent));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    memoComponent = memo(useWrappedComponent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memoComponent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lesson7-详解mobx-react-lite的useAsObservableSource的使用场景及实现"><a href="#lesson7-详解mobx-react-lite的useAsObservableSource的使用场景及实现" class="headerlink" title="lesson7-详解mobx-react-lite的useAsObservableSource的使用场景及实现"></a>lesson7-详解mobx-react-lite的useAsObservableSource的使用场景及实现</h3><p><strong><a href="mailto:&#x6d;&#111;&#98;&#x78;&#x2d;&#x72;&#101;&#97;&#99;&#x74;&#x2d;&#108;&#x69;&#x74;&#101;&#64;&#49;&#x2e;&#x33;&#46;&#x30;">&#x6d;&#111;&#98;&#x78;&#x2d;&#x72;&#101;&#97;&#99;&#x74;&#x2d;&#108;&#x69;&#x74;&#101;&#64;&#49;&#x2e;&#x33;&#46;&#x30;</a></strong></p><p>在不改变原先逻辑的基础上使用mobX。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useAsObservableSource&lt;T&gt;(state: T): T</span><br></pre></td></tr></table></figure><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>action接收一个函数并返回具有同样签名的函数，但是用 <code>transaction</code>、<code>untracked</code> 和 <code>allowStateChanges</code> 包裹起来，尤其是 <code>transaction</code> 的自动应用会产生巨大的性能收益， 动作会分批处理变化并只在(最外层的)动作完成后通知计算值和反应。 这将确保在动作完成之前，在动作期间生成的中间值或未完成的值对应用的其余部分是不可见的。</p><p>建议对任何修改 observables 或具有副作用的函数使用 <code>(@)action</code> 。 结合开发者工具的话，动作还能提供非常有用的调试信息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, action &#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = observable(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> increment = action(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    state.value++</span><br><span class="line">    state.value++</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">increment(state)</span><br></pre></td></tr></table></figure><h4 id="runInAction-fn"><a href="#runInAction-fn" class="headerlink" title="runInAction(fn)"></a>runInAction(fn)</h4><p><code>runInAction</code> 是个简单的工具函数，它接收代码块并在(异步的)动作中执行。这对于即时创建和执行动作非常有用，例如在异步过程中。<code>runInAction(f)</code> 是 <code>action(f)()</code> 的语法糖。如参考上面action的例子，如果increment只用一次，不想再创建的话，就可以换成用下面的runInAction的写法了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable &#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = observable(&#123; <span class="attr">value</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">runInAction(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    state.value++</span><br><span class="line">    state.value++</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再参考个异步的例子，使用async/await + runInAction：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; runInAction, makeAutoObservable &#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">    githubProjects = []</span><br><span class="line">    state = <span class="string">&quot;pending&quot;</span> <span class="comment">// &quot;pending&quot; / &quot;done&quot; / &quot;error&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        makeAutoObservable(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">fetchProjects</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.githubProjects = []</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;pending&quot;</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> projects = <span class="keyword">await</span> fetchGithubProjectsSomehow()</span><br><span class="line">            <span class="keyword">const</span> filteredProjects = somePreprocessing(projects)</span><br><span class="line">            runInAction(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.githubProjects = filteredProjects</span><br><span class="line">                <span class="built_in">this</span>.state = <span class="string">&quot;done&quot;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            runInAction(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.state = <span class="string">&quot;error&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自己手动实现useAsObservableSource-js"><a href="#自己手动实现useAsObservableSource-js" class="headerlink" title="自己手动实现useAsObservableSource.js"></a>自己手动实现useAsObservableSource.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;observable, runInAction&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useAsObservableSource</span>(<span class="params">current</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [res] = React.useState(<span class="function">() =&gt;</span> observable(current));</span><br><span class="line"></span><br><span class="line">  runInAction(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(res, current);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lesson8-实现mobx-react-lite的useLocalStore"><a href="#lesson8-实现mobx-react-lite的useLocalStore" class="headerlink" title="lesson8-实现mobx-react-lite的useLocalStore"></a>lesson8-实现mobx-react-lite的useLocalStore</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useLocalStore&lt;T, S&gt;(initializer: <span class="function">() =&gt;</span> T, source?: S): T</span><br></pre></td></tr></table></figure><h4 id="transaction-事务"><a href="#transaction-事务" class="headerlink" title="transaction(事务)"></a>transaction(事务)</h4><p><em>transaction 是底层 API，在绝大多数场景下 action 或 runInAction 会是更好的选择</em></p><p><code>transaction(worker: () =&gt; void)</code> 可以用来批量更新，在事务结束前不会通知任何观察者。 <code>transaction</code> 接收一个无参数的 <code>worker</code> 函数作为参数并运行它。 这个函数完成运行前不会通知任何观察者。 <code>transaction</code> 返回 <code>worker</code> 函数返回的任何值。 注意 <code>transaction</code> 完全是同步运行的。 Transactions 可以嵌套。只有在完成最外面的 <code>transaction</code> 后，其他等待的 reaction 才会运行。</p><h4 id="实现useLocalStore"><a href="#实现useLocalStore" class="headerlink" title="实现useLocalStore"></a>实现useLocalStore</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;observable, runInAction, transaction&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;useAsObservableSource&#125; <span class="keyword">from</span> <span class="string">&quot;./useAsObservableSource&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useLocalStore</span>(<span class="params">initializer, current</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> source = useAsObservableSource(current);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> React.useState(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> local = observable(initializer(source));</span><br><span class="line">    runInAction(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(local).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value = local[key];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">          local[key] = wrapInTransaction(value, local);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> local;</span><br><span class="line">  &#125;)[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapInTransaction</span>(<span class="params">fn, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> transaction(<span class="function">() =&gt;</span> fn.apply(context, args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>注意：useObserver能引起组件的整体渲染，如果想要局部控制的话，可以使用Observer Component。代码示例如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  useLocalStore,</span><br><span class="line">  useObserver,</span><br><span class="line">  useAsObservableSource,</span><br><span class="line">  Observer</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;../k-mobx-react-lite/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UseLocalStore</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;sss&quot;</span>); <span class="comment">//sy-log</span></span><br><span class="line">  <span class="keyword">const</span> newProps = &#123;...props&#125;; <span class="comment">// useAsObservableSource(props);</span></span><br><span class="line">  <span class="comment">// useLocalStore第一个参数是一个初始化函数，并且这个函数只会执行一次，并且在整个生命周期中都是有效的</span></span><br><span class="line">  <span class="keyword">const</span> countStore = useLocalStore(</span><br><span class="line">    <span class="function"><span class="params">newProps</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">count</span>: props.init === <span class="literal">undefined</span> ? <span class="number">0</span> : props.init,</span><br><span class="line">      <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = <span class="built_in">this</span>.count + <span class="number">1</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">get</span> <span class="title">emoji</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count % <span class="number">2</span> ? <span class="string">&quot;😜&quot;</span> : <span class="string">&quot;🏃&quot;</span>;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">get</span> <span class="title">specialNum</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> newProps.init &gt; -<span class="number">1</span> &amp;&amp; newProps.init &lt; <span class="number">10</span></span><br><span class="line">          ? <span class="string">&quot;0&quot;</span> + newProps.init</span><br><span class="line">          : newProps.init;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;),</span><br><span class="line">    newProps</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// return useObserver(() =&gt; (</span></span><br><span class="line">  <span class="comment">//   &lt;div className=&quot;border&quot;&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;h3&gt;UseLocalStore&lt;/h3&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;button onClick=&#123;countStore.add&#125;&gt;count: &#123;countStore.count&#125;&lt;/button&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;p&gt;&#123;countStore.emoji&#125;&lt;/p&gt;</span></span><br><span class="line">  <span class="comment">//     &lt;p&gt;&#123;countStore.specialNum&#125;&lt;/p&gt;</span></span><br><span class="line">  <span class="comment">//   &lt;/div&gt;</span></span><br><span class="line">  <span class="comment">// ));</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 局部控制</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Observer</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;() =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;border&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">h3</span>&gt;</span>UseLocalStore<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;countStore.add&#125;</span>&gt;</span>count: &#123;countStore.count&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;countStore.emoji&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;countStore.specialNum&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Observer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> UseLocalStore;</span><br></pre></td></tr></table></figure><h3 id="lesson9-实现mobx-react的observer"><a href="#lesson9-实现mobx-react的observer" class="headerlink" title="lesson9-实现mobx-react的observer"></a>lesson9-实现mobx-react的observer</h3><p>mobx-react@6以后，mobx-react的observer中会判断下是否是函数组件，如果是函数组件，则用的还是mobx-react-lite中的observer，如果是类组件，则调用makeClassComponentObserver。</p><p>注意区分：目前<a href="mailto:&#x6d;&#x6f;&#x62;&#x78;&#45;&#114;&#x65;&#x61;&#x63;&#116;&#x2d;&#x6c;&#105;&#116;&#x65;&#64;&#x32;&#46;&#x32;">&#x6d;&#x6f;&#x62;&#x78;&#45;&#114;&#x65;&#x61;&#x63;&#116;&#x2d;&#x6c;&#105;&#116;&#x65;&#64;&#x32;&#46;&#x32;</a>中的observer有forwardRef配置项，但是目前<a href="mailto:&#x6d;&#x6f;&#98;&#120;&#x2d;&#x72;&#101;&#97;&#99;&#x74;&#64;&#x36;&#x2e;&#51;&#46;&#x30;">&#x6d;&#x6f;&#98;&#120;&#x2d;&#x72;&#101;&#97;&#99;&#x74;&#64;&#x36;&#x2e;&#51;&#46;&#x30;</a>不支持，需要自己配置。</p><p>实现代码如下：</p><h4 id="observer"><a href="#observer" class="headerlink" title="observer"></a>observer</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;observer <span class="keyword">as</span> observerLite, Observer&#125; <span class="keyword">from</span> <span class="string">&quot;../k-mobx-react-lite/&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;makeClassComponentObserver&#125; <span class="keyword">from</span> <span class="string">&quot;./observerClass&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">component, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// forwardRef</span></span><br><span class="line">  <span class="keyword">if</span> (component[<span class="string">&quot;$$typeof&quot;</span>] === <span class="built_in">Symbol</span>.for(<span class="string">&quot;react.forward_ref&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> baseRender = component[<span class="string">&quot;render&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> React.forwardRef(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Observer</span>&gt;</span>&#123;() =&gt; baseRender.apply(undefined, args)&#125;<span class="tag">&lt;/<span class="name">Observer</span>&gt;</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数组件</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (<span class="keyword">typeof</span> component === <span class="string">&quot;function&quot;</span> &amp;&amp; !component.prototype) ||</span><br><span class="line">    !component.prototype.render</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> observerLite(component, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 类组件</span></span><br><span class="line">  <span class="keyword">return</span> makeClassComponentObserver(component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="makeClassComponentObserver"><a href="#makeClassComponentObserver" class="headerlink" title="makeClassComponentObserver"></a>makeClassComponentObserver</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Reaction&#125; <span class="keyword">from</span> <span class="string">&quot;mobx&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">makeClassComponentObserver</span>(<span class="params">componentClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> target = componentClass.prototype;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> baseRender = target.render;</span><br><span class="line">  target.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> makeComponentReactive.call(<span class="built_in">this</span>, baseRender);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> componentClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeComponentReactive</span>(<span class="params">render</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> baseRender = render.bind(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">let</span> isRenderingPending = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> reaction = <span class="keyword">new</span> Reaction(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.constructor.name&#125;</span>.render`</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isRenderingPending) &#123;</span><br><span class="line">      isRenderingPending = <span class="literal">true</span>;</span><br><span class="line">      Component.prototype.forceUpdate.call(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.render = reactiveRender;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reactiveRender</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    isRenderingPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">let</span> rendering = <span class="literal">undefined</span>;</span><br><span class="line">    reaction.track(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      rendering = baseRender();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rendering;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reactiveRender.call(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="lesson10-mobx-react的Provider、inject的使用"><a href="#lesson10-mobx-react的Provider、inject的使用" class="headerlink" title="lesson10-mobx-react的Provider、inject的使用"></a>lesson10-mobx-react的Provider、inject的使用</h3><p><code>Provider</code>是个能够传递store的组件，也支持传递其他非store数据，其实现机制就是React的Context跨层级传递。如果你有一些需要跨层级数据需要传递，可以考虑下这个组件。</p><p><code>inject</code>可以用于提取你传输的数据的store，本质上是个高阶组件（hoc）。</p><p>参考下面的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@inject(<span class="string">&quot;color&quot;</span>)</span><br><span class="line">@observer</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span> <span class="attr">this.props.color</span> &#125;&#125;&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                &#123;this.props.text&#125; <span class="tag">&lt;<span class="name">Button</span>&gt;</span>Delete<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> children = <span class="built_in">this</span>.props.messages.map(<span class="function"><span class="params">message</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">Message</span> <span class="attr">text</span>=<span class="string">&#123;message.text&#125;</span> /&gt;</span></span>)</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>读取Provider提供的数据不是非得用inject，用React.useContext(MobXProviderContext)也可以，MobXProviderContext来自mobx-react。</li><li>使用inject和observer的时候，注意顺序，observer应该是内部，inject在外面。</li></ul><h3 id="lesson11-实现mobx-react的Provider、inject"><a href="#lesson11-实现mobx-react的Provider、inject" class="headerlink" title="lesson11-实现mobx-react的Provider、inject"></a>lesson11-实现mobx-react的Provider、inject</h3><p>Provider基于Context与组件复合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useRef, useContext&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;MobXProviderContext&#125; <span class="keyword">from</span> <span class="string">&quot;./MobXProviderContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">Provider</span>(<span class="params">&#123;children, ...stores&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parentValue = useContext(MobXProviderContext);</span><br><span class="line">  <span class="keyword">const</span> mutableProvdierRef = useRef(&#123;...parentValue, ...stores&#125;);</span><br><span class="line">  <span class="keyword">const</span> value = mutableProvdierRef.current;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">MobXProviderContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;children&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">MobXProviderContext.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inject基于高阶组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;useContext&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;MobXProviderContext&#125; <span class="keyword">from</span> <span class="string">&quot;./MobXProviderContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> inject = <span class="function">(<span class="params">...storeNames</span>) =&gt;</span> <span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> Injector = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> context = useContext(MobXProviderContext);</span><br><span class="line">    <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      ...context</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">      newProps.ref = ref;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(component, newProps);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Injector;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="lesson12-实现mobx的observable"><a href="#lesson12-实现mobx的observable" class="headerlink" title="lesson12-实现mobx的observable"></a>lesson12-实现mobx的observable</h3><p>MobX 为现有的数据结构(如对象，数组和类实例)添加了可观察的功能，我们通过使用 observable就可以简单地完成这一切。</p><p>Observable 值可以是JS基本数据类型、引用类型、普通对象、类实例、数组和映射。</p><h4 id="实现observable"><a href="#实现observable" class="headerlink" title="实现observable"></a>实现observable</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> observable = assign(createObservable, observableFactories)</span><br></pre></td></tr></table></figure><h4 id="实现extendObservable"><a href="#实现extendObservable" class="headerlink" title="实现extendObservable"></a>实现extendObservable</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extendObservable(target, properties, decorators?, options?)</span><br></pre></td></tr></table></figure><p>extendObservable用来向已存在的目标对象添加 observable 属性。 属性映射中的所有键值对都会导致目标上的新的 observable 属性被初始化为给定值。 属性映射中的任意 getters 都会转化成计算属性。</p><p><code>decorators</code> 参数用来重载用于指定属性的装饰器，类似于 <code>decorate</code> 和 <code>observable.object</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;asObservableObject&#125; <span class="keyword">from</span> <span class="string">&quot;./observableObject&quot;</span>;</span><br><span class="line"><span class="comment">// import &#123;makeProperty&#125; from &quot;./makeObservable&quot;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">extendObservable</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// step1</span></span><br><span class="line">  <span class="keyword">const</span> adm = asObservableObject(target);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// step2</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(props).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// makeProperty(adm, target, key, props[key]);</span></span><br><span class="line">    adm.addObservableProp_(key, props[key]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与observable无依赖关系</p><p>本地的observable state可以使用useLocalStore，但是记住一点就是对于每个组件实例，useLocalStore的<strong>初始化函数只会执行一次</strong>，并且是在组件的整个生命周期里都有效。</p><p>useLocalStore支持你传递一个非observable的plain object作为第二个参数存在这个store的衍生里，它可以是props、useContext甚至是useReducer。当然，这个参数必须得始终保持一种结构，不能用在条件语句中。</p><p>注：useLocalStore与useAsObservableSource的区别在于后者只能用于object，如果你不需要action和computed属性，那完全可以使用后者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; observer, useLocalStore &#125; from &#x27;mobx-react&#x27; // 6.x</span><br><span class="line"></span><br><span class="line">export const Counter = observer(props =&gt; &#123;</span><br><span class="line">  const store = useLocalStore(</span><br><span class="line">    // don&#x27;t ever destructure source, it won&#x27;t work</span><br><span class="line">    source =&gt; (&#123;</span><br><span class="line">      count: props.initialCount,</span><br><span class="line">      get multiplied() &#123;</span><br><span class="line">        // you shouldn&#x27;t ever refer to props directly here, it won&#x27;t see a change</span><br><span class="line">        return source.multiplier * store.count</span><br><span class="line">      &#125;,</span><br><span class="line">      inc() &#123;</span><br><span class="line">        store.count += 1</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">    props, // note props passed here</span><br><span class="line">  )</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;button id=&quot;inc&quot; onClick=&#123;store.inc&#125;&gt;</span><br><span class="line">        &#123;`Count: $&#123;store.count&#125;`&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">      &lt;span&gt;&#123;store.multiplied&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="lesson-13mobx与redux"><a href="#lesson-13mobx与redux" class="headerlink" title="lesson-13mobx与redux"></a>lesson-13mobx与redux</h3><h4 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h4><p>它通过透明的函数响应式编程(transparently applying functional reactive programming - TFRP)使得状态管理变得简单和可扩展。MobX背后的哲学很简单:</p><p><em>任何源自应用状态的东西都应该自动地获得。</em></p><p><img src="https://cn.mobx.js.org/flow.png" alt="MobX unidirectional flow"></p><h4 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h4><p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc57dy6j70j31240netja.jpg" alt="image-20200222151958879"></p><p>Redux 除了和 <a href="https://facebook.github.io/react/">React</a> 一起用外，还支持其它界面库。 它体小精悍（只有2kB，包括依赖）。</p><p>应用中所有的 state 都以一个对象树的形式储存在一个单一的 <em>store</em> 中。 惟一改变 state 的办法是触发 <em>action</em>，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写 <em>reducers</em>。</p><h5 id="redux三大原则"><a href="#redux三大原则" class="headerlink" title="redux三大原则"></a>redux三大原则</h5><h6 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h6><p>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</p><h6 id="State-是只读的"><a href="#State-是只读的" class="headerlink" title="State 是只读的"></a>State 是只读的</h6><p>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</p><h6 id="使用纯函数来执行修改"><a href="#使用纯函数来执行修改" class="headerlink" title="使用纯函数来执行修改"></a>使用纯函数来执行修改</h6><p>为了描述 action 如何改变 state tree ，你需要编写 reducers。</p><h4 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h4><h5 id="设计思想不同"><a href="#设计思想不同" class="headerlink" title="设计思想不同"></a>设计思想不同</h5><p>Redux遵循函数式编程（Functional Programming, FP）思想，而MobX设计更多偏向于面向对象编程（OOP）和响应式编程（Reactive Programming），MobX中将状态包装成可观察对象，再使用可观察对象的所有能力，一旦状态对象变更，更新就能被自动获得。</p><h5 id="对store管理的不同"><a href="#对store管理的不同" class="headerlink" title="对store管理的不同"></a>对store管理的不同</h5><p>在Redux应用中，所有共享的应用数据都集中在一个大的store中，而MboX则通常按模块将应用状态划分，在多个独立的store中管理。</p><h5 id="工作方式不同"><a href="#工作方式不同" class="headerlink" title="工作方式不同"></a>工作方式不同</h5><p>Redux中用js对象存储状态数据，并且手动追踪状态变更，而MobX中会把状态数据转化为可观察的对象，当状态发生变化，自动触发监听。</p><h5 id="状态修改方式"><a href="#状态修改方式" class="headerlink" title="状态修改方式"></a>状态修改方式</h5><p>Redux中的不可以直接修改状态，只能通过dispatch派发事件修改，而MobX中则可以直接修改，也可以通过action修改，比较”灵活“，但是这种灵活不利于项目管理与维护，因此建议还是开启严格模式，从而禁止掉直接修改状态的方式，并且制定状态管理规范。</p><h5 id="不可变（Immutable）和可变（Mutable）"><a href="#不可变（Immutable）和可变（Mutable）" class="headerlink" title="不可变（Immutable）和可变（Mutable）"></a>不可变（Immutable）和可变（Mutable）</h5><p>Redux状态对象通常是不可变的（Immutable），我们使用reducers，并且在原来对象的基础上返回一个新的状态对象，这样就能很方便的返回上一个状态，但是MobX中则可由直接使用新值更新状态对象。</p><h5 id="mobx-react和react-reudx"><a href="#mobx-react和react-reudx" class="headerlink" title="mobx-react和react-reudx"></a>mobx-react和react-reudx</h5><p>各自都有React绑定库，且绑定库设计与思想相似，react-redux中有Provider与connect，mobx-react中有Provider和inject，都有Context和HOC设计，后期都可以用hooks代替。</p><h5 id="体积不同"><a href="#体积不同" class="headerlink" title="体积不同"></a>体积不同</h5><p>Redux体小精悍、周边配合库非常丰富，如redux-thunk中间件等。mobx库则功能强大，自己就能独立完成很多功能，如异步等。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>如果你不懂Redux中的reducers、中间件等这些概念，<code>MobX</code>入门也许相对简单，构建项目当然也很快，但是当项目足够大的时候，其实难度不会天差地别，都需要开发者对库本身能有深刻的理解。目前更多人选择使用Redux，尤其是大型项目，而选择MobX的则中小型项目多一些，MobX好理解、自由，这当然是个优势，但是同时也带来了劣势，过于自由对于项目管理当然是巨大的缺点，因此使用MobX需要开发者约定规范。所以，我个人认为，选择MobX还是Redux用于状态管理，或者你有第三第四个别的选择，根据自己的项目和个人对于各自库的掌握度来做选择就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MobX文档&quot;&gt;&lt;a href=&quot;#MobX文档&quot; class=&quot;headerlink&quot; title=&quot;MobX文档&quot;&gt;&lt;/a&gt;MobX文档&lt;/h1&gt;&lt;h2 id=&quot;资源&quot;&gt;&lt;a href=&quot;#资源&quot; class=&quot;headerlink&quot; title=&quot;资源&quot;&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>regular-expression</title>
    <link href="http://example.com/2021/10/08/regular-expression/"/>
    <id>http://example.com/2021/10/08/regular-expression/</id>
    <published>2021-10-08T00:00:00.000Z</published>
    <updated>2021-11-08T16:15:04.548Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在编程语言中，正则常常用来简化文本处理的逻辑。在 Linux 命令中，它也可以帮助我们轻松地查找或编辑文件的内容，甚至实现整个文件夹中所有文件的内容替换，比如 grep、egrep、sed、awk、vim 等。另外，在各种文本编辑器中，比如 Atom，Sublime Text 或 VS Code 等，在查找或替换的时候也会使用到它。总之，正则是无处不在的，已经渗透到了日常工作的方方面面。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>正则表达式解决流程</p><p><strong>第一步,做分解</strong>。拿到一个问题后，我们要先思考：这个问题可以分为几个子问题？每个子问题是否独立？我们拿最常见的电子邮件地址匹配来说。从文本结构来看，它可以分为“username + @ + domain name”这三个独立的部分。怎么画呢？我们可以先画出逻辑结构图。通过这个过程来厘清思路。当然，这是软件⼯程最基本的思路，相信你做起来应该问题不大。</p><p><strong>第二部，分析各个子问题</strong>。某个位置上可能有多个字符？那就用字符组。某个位置上可能有多个字符串？那就用多选结构。出现的次数不确定？那就用量词。对出现的位置有要求？那就用锚点锁定位置…… 某种程度上，这就像武术里的见招拆招，每个问题都有对应的解法，只要熟练掌握了，知道什么时候用字符组，什么时候用多选结构，什么时候用量词，什么时候用锚点，就很容易搭建起完整的概念模型。</p><p><strong>第三部，套皮</strong>。你大概注意到了，到现在，我们还没有谈论正则表达式的典型标志，比如方括号、星号、花括号。要知道，这些典型标志无非只是一些符号而已，真正重要的是字符组、多选结构、量词等等这些概念。一旦你的概念模型清楚了，写出正则表达式就非常简单了，无非是查阅语法手册，把之前得到的概念模型按照对应语言或工具的约定写下来而已。许多人觉得正则表达式难懂，总是纠缠于“这里为什么要多一个星号？那里为什么是方括号而不是花括号？”，原因恰恰在于对概念模型不清楚。虽然各种语言或工具对正则表达式的支持大同小异，但细微差别仍然不可忽视。不过只要你心怀正念，洞若观火，这些差异其实并不是大问题。</p><p><strong>第四步,调试</strong>。很多人都说，正则表达式的麻烦之处在于它像个黑箱子，很难调试，迄今为止仍然没有特别好用的⼯具，所以我们没法⼀步步跟进去看匹配的具体过程，只能笼统地知道“匹配了”或者“没匹配”。</p><h3 id="书写注意事项"><a href="#书写注意事项" class="headerlink" title="书写注意事项"></a>书写注意事项</h3><p><strong>第⼀，能用普通字符串处理的，坚决⽤普通字符串处理</strong>。字符串处理的速度不见得差，可读性却好上很多。如果要在大段文本中定位所有的 today 或者 tomorrow，用最简单的字符串查找，直接找两遍，明显比 to(day|morrow) 看起来更清楚。</p><p><strong>第⼆，能写注释的正则表达式，⼀定要写注释</strong>。正则表达式的语法非常古老，不够直观，为了便于阅读和维护，如今大部分语言里都可以通过 x 打开注释模式。有了注释，复杂正则表达式的结构也能一目了然。</p><p><strong>第三，能用多个简单正则表达式解决的，⼀定不要苛求用一个复杂的正则表达式</strong>。这里最明显的例子就是输入条件的验证。比如说，常见的密码要求“必须包含数字、小写字母、大写字母、特殊符号中的至少两种，且长度在 8 到 16 之间”。</p><h3 id="元字符的概念"><a href="#元字符的概念" class="headerlink" title="元字符的概念"></a>元字符的概念</h3><p>元字符就是指那些在正则表达式中具有特殊意义的专用字符</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gune2cb9mej60i80o7abf02.jpg" alt="image-20210920205711717"></p><h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><p><strong>定义</strong>：表示次数的量词，尽可能最大长度去匹配字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="regexp">/a*/g</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;aaabb&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> array = [...str.matchAll(regexp)];</span><br><span class="line"><span class="built_in">console</span>.log(array)</span><br></pre></td></tr></table></figure><p>结果如下:</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsx1r8lhb8j30om04k757.jpg" alt="image-20210728224622226"></p><p>使用 a* 在 aaabb 这个字符串中进行查找，这次我们看到可以找到 4 个匹配结果</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsx1x70sjgj30gy086dg9.jpg" alt="image-20210728225205119"></p><p>a* 在匹配开头的 a 时，会尝试尽量匹配更多的 a，直到第一个字母 b 不满足要求为止，匹配上三个 a，后面每次匹配时都得到了空字符串。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gunej0p277j60f107fgly02.jpg" alt="image-20210920211316195"></p><p>regex = “xy{1,3}z”</p><p>text = “xyyz”</p><p>在匹配时，y{1,3}会尽可能长地去匹配，当匹配完 xyy 后，由于 y 要尽可能匹配最长，即三个，但字符串中后面是个 z 就会导致匹配不上，这时候正则就会向前回溯，吐出当前字符 z，接着用正则中的 z 去匹配。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gt1jicfk3xj30hh06zaaa.jpg" alt="image-20210801200251574"></p><h3 id="非贪婪模式"><a href="#非贪婪模式" class="headerlink" title="非贪婪模式"></a>非贪婪模式</h3><p><strong>定义</strong>：”数量”元字符后加?,找出长度最小且满足要求的的字符串， 尽可能短地去匹配字符串</p><p>regex = “xy{1,3}?z”</p><p>text = “xyyz”</p><p>由于 y{1,3}? 代表匹配 1 到 3 个 y，尽可能少地匹配。匹配上一个 y 之后，也就是在匹配上 text 中的 xy 后，正则会使用 z 和 text 中的 xy 后面的 y 比较，发现正则 z 和 y 不匹配，这时正则就会向前回溯，重新查看 y 匹配两个的情况，匹配上正则中的 xyy，然后再用 z 去匹配 text 中的 z，匹配成功。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gt1jh4ead2j30g806jjro.jpg" alt="image-20210801200140585"></p><h3 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h3><p>不管是贪婪模式，还是非贪婪模式，都需要发生回溯才能完成相应的功能，但是在一些场景下，我们不需要回溯，匹配不上返回失败就好了，独占模式类似贪婪匹配，但匹配过程不会发生回溯。具体方法在量词后面加上加号(+)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.findall(<span class="string">&#x27;xy&#123;1,3&#125;+yz&#x27;</span>,<span class="string">&#x27;xyyz&#x27;</span>)</span><br></pre></td></tr></table></figure><p>不过在python中会报错(目前python和go标准库并不支持独占模式) 加号会被程序认为是重复次数的元字符</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gt1akx83trj30u009ijsw.jpg" alt="image-20210801145354310"></p><p>可以安装regex模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> regex</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>regex.findall(<span class="string">r&#x27;xy&#123;1,3&#125;z&#x27;</span>, <span class="string">&#x27;xyyz&#x27;</span>)  <span class="comment"># 贪婪模式</span></span><br><span class="line">[<span class="string">&#x27;xyyz&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>regex.findall(<span class="string">r&#x27;xy&#123;1,3&#125;+z&#x27;</span>, <span class="string">&#x27;xyyz&#x27;</span>) <span class="comment"># 独占模式</span></span><br><span class="line">[<span class="string">&#x27;xyyz&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>regex.findall(<span class="string">r&#x27;xy&#123;1,2&#125;+yz&#x27;</span>, <span class="string">&#x27;xyyz&#x27;</span>) <span class="comment"># 独占模式</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>正则</th><th>文本</th><th>结果</th></tr></thead><tbody><tr><td>贪婪模式</td><td>x{1,3}xy</td><td>xxxy</td><td>匹配</td></tr><tr><td>非贪婪模式</td><td>x{1,3}?xy</td><td>xxxy</td><td>匹配</td></tr><tr><td>独占模式</td><td>x{1,3}+xy</td><td>xxxy</td><td>不匹配</td></tr></tbody></table><p>如果用x{1,3}+xy去匹配xxxy字符串，x{1,3}会把前面三个x都用掉,那文本中只剩下一个y，正则+后面的x无法匹配，导致匹配失败。</p><p><strong>造成回溯的条件</strong></p><ul><li>多分枝结构</li><li>量词</li></ul><h3 id="分组与引用"><a href="#分组与引用" class="headerlink" title="分组与引用"></a>分组与引用</h3><p>分组用括号括起</p><ul><li>可以表示一个整体</li><li>复用</li></ul><h4 id="分组与编号"><a href="#分组与编号" class="headerlink" title="分组与编号"></a>分组与编号</h4><p>括号在正则中可以用于分组，被括号括起来的部分”子表达式“会被保存成一个子组。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gt1mz7ebksj30h605jq2z.jpg" alt="image-20210801220251264"></p><p>如果括号嵌套的话，只需要数左括号是第几个，就可以确定是第几个子组</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gt1n39gosfj30g503owej.jpg" alt="image-20210801220645844"></p><p>不保存子组可以提高正则性能 在括号里面加?:</p><p>保存子组后续可以继续使用</p><h4 id="命名分组"><a href="#命名分组" class="headerlink" title="命名分组"></a>命名分组</h4><p>前面我们讲了分组编号，但由于编号得数在第几个位置，后续如果发现正则有问题，改动了括号的个数，还可能导致编号发生变化，因此一些编程语言提供了命名分组（named grouping），这样和数字相比更容易辨识，不容易出错。命名分组的格式为(?P&lt;分组名&gt;正则)</p><table><thead><tr><th>编程语言</th><th>查找时引用方式</th><th>替换时引用方式</th></tr></thead><tbody><tr><td>Python</td><td>\number 如\1</td><td>\number 如\1</td></tr><tr><td>Go</td><td>官方包不支持</td><td>官方包不支持</td></tr><tr><td>Java</td><td>\number 如\1</td><td>$number, 如$1</td></tr><tr><td>JavaScript</td><td>$number,如$1</td><td>$number，如$1</td></tr><tr><td>PHP</td><td>\number 如\1</td><td>\number 如\1</td></tr><tr><td>Ruby</td><td>\number 如\1</td><td>\number 如\1</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">the little cat cat is <span class="keyword">in</span> the hat hat hat, we like it.</span><br><span class="line"></span><br><span class="line">查找匹配</span><br><span class="line">/(\b\w+\b)(?:\s+\<span class="number">1</span>)+/gm</span><br><span class="line">  </span><br><span class="line">替换匹配</span><br><span class="line">/<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例分享: <a href="https://regex101.com/r/2RVPTJ/2">https://regex101.com/r/2RVPTJ/2</a> </p><h4 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h4><h3 id="匹配模式-1"><a href="#匹配模式-1" class="headerlink" title="匹配模式"></a>匹配模式</h3><p>概念: 正则中一些改变元字符匹配行为的方式</p><h4 id="不区分大小写模式"><a href="#不区分大小写模式" class="headerlink" title="不区分大小写模式"></a>不区分大小写模式</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtsa56ct57j60ex05nq2y02.jpg" alt="image-20210824230903544"></p><ol><li>不区分大小写模式的指定方式，使用模式修饰符(?i);</li><li>修饰符如果在括号内，作用范围是这个括号内的正则，而不是整个正则</li><li>使用编程语言时可以使用预定义好的常量来指定匹配模式</li><li>在js中需要使用/regex/i来指定匹配模式。</li></ol><h4 id="点号通配模式"><a href="#点号通配模式" class="headerlink" title="点号通配模式"></a>点号通配模式</h4><p>让英文的点可以匹配上包括换行的任何字符</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtsb75mjxaj60ra04p0sy02.jpg" alt="image-20210824234533681"></p><p><strong>在js中不支持这种语法，可以用[\s\S]+代替</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtsb9hlpfrj60r904j0sv02.jpg" alt="image-20210824234748287"></p><h4 id="多行匹配模式"><a href="#多行匹配模式" class="headerlink" title="多行匹配模式"></a>多行匹配模式</h4><p>概念：^匹配整个字符串的开头，$ 匹配整个字符串的结尾。多行匹配模式改变的就是 ^ 和 $ 的匹配行为</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtsbewqh6wj60r70443yk02.jpg" alt="image-20210824235301168"></p><p>多行模式的作用在于，使 ^ 和 $ 能匹配上每行的开头或结尾，我们可以使用模式修饰符号 (?m) 来指定这个模式。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtsbfuf0qhj60r903vq3202.jpg" alt="image-20210824235354546"></p><h4 id="注释模式"><a href="#注释模式" class="headerlink" title="注释模式"></a>注释模式</h4><p>在实际工作中，正则可能会很复杂，这就导致编写、阅读和维护正则都会很困难。我们在写代码的时候，通常会在一些关键的地方加上注释，让代码更易于理解。很多语言也支持在正则中添加注释，让正则更容易阅读和维护，这就是正则的注释模式。正则中注释模式是使用 (?#comment) 来表示</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtsbpks8apj60qy06n3ys02.jpg" alt="image-20210825000315718"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="string">&#x27;cat cat CAt cAt caT CAT Dog Dog ABC ABC&#x27;</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/((?i)(\w+))(?#word) \1(?#word repeat again)/gm</span></span><br></pre></td></tr></table></figure><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>什么是断言呢？简单来说，断言是指对匹配到的文本位置有要求。比如\d{11} 能匹配上 11 位数字，但这 11 位数字可能是 18 位身份证号中的一部分。再比如，去查找一个单词，我们要查找 tom，但其它的单词，比如 tomorrow 中也包含了 tom。也就是说，在有些情况下，我们对要匹配的文本的位置也有一定的要求。为了解决这个问题，正则中提供了一些结构，只用于匹配位置，而不是文本内容本身，这种结构就是断言。常见的断言有三种：单词边界、行的开始或结束以及环视</p><h4 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="string">&#x27;tom asked me if I would go fishing with him tomorrow.&#x27;</span></span><br><span class="line"><span class="comment">//匹配tom这个单词</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/\btom\b/</span></span><br></pre></td></tr></table></figure><p>单词的组成一般可以用元字符 \w+ 来表示，\w 包括了大小写字母、下划线和数字（即 [A-Za-z0-9_]）。那如果我们能找出单词的边界，也就是当出现了\w 表示的范围以外的字符，比如引号、空格、标点、换行等这些符号，我们就可以在正则中使用\b 来表示单词的边界。 \b 中的 b 可以理解为是边界（Boundary）这个单词的首字母。</p><h4 id="行的开始-结束"><a href="#行的开始-结束" class="headerlink" title="行的开始/结束"></a>行的开始/结束</h4><p>如果我们要求匹配的内容要出现在一行文本开头或结尾，就可以使用 ^ 和 $ 来进行位置界定</p><ul><li>\A 匹配整个字符串的开始，可以匹配任意行结尾，不支持多行模式</li><li>\z仅匹配整个字符串的结束，不支持多行模式</li></ul><p>应用: </p><p><strong>日志起始行的判断</strong> </p><p>最常见的例子就是日志收集，我们在收集日志的时候，通常可以指定日志行的开始规则，比如以时间开头，那些不是以时间开头的可能就是打印的堆栈信息，我们就通过日期时间开头来判断哪一行是日志的第一行，在日期时间后面的日志都属于同一条日志。除非我们看见下一个日期时间的出现，才是下一条日志的开始</p><p> <strong>输入数据校验</strong></p><p>在 Web 服务中，我们常常需要对输入的内容进行校验，比如要求输入 6 位数字，我们可以使用 \d{6} 来校验。但你需要注意到，如果用户输入的是 6 位以上的数字呢？在这种情况下，如果不去要求用户录入的 6 位数字必须是行的开头或结尾，就算验证通过了，结果也可能不对。比如下面的示例，在不加行开始和结束符号时，用户输入了 7 位数字，也是能校验通过的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> template = <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/^\d&#123;6&#125;$/</span>;</span><br><span class="line"><span class="built_in">console</span>.log(template.match(regex));</span><br></pre></td></tr></table></figure><h4 id="环视"><a href="#环视" class="headerlink" title="环视"></a>环视</h4><p>环视就是要求匹配部分的前面或后面要满足（或不满足）某种规则，有些地方也称环视为零宽断言</p><table><thead><tr><th>正则</th><th>名称</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>(?&lt;=Y)</td><td>肯定逆序环视postive-lookbehind</td><td>左边是Y</td><td>(?&lt;=\d)th左边是数字的th，能匹配1th</td></tr><tr><td>(?&lt;!Y)</td><td>否定逆序环视negative-lookbehind</td><td>左边不是Y</td><td>(?&lt;!\d)th左边不是数字的th，能匹配health</td></tr><tr><td>(?=Y)</td><td>肯定顺序环视postive-lookahead</td><td>右边是Y</td><td>Six(?=\d)右边是数字的Six,能匹配Six6</td></tr><tr><td>(?!Y)</td><td>否定顺序环视negative-lookahead</td><td>右边不是Y</td><td>hi(?!\d) 右边不是数字的hi，能匹配high</td></tr></tbody></table><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>​    <strong>维基百科:</strong> 在计算机科学与远程通信中，当转义字符放在字符序列中，它将对它后续的几个字符进行替代并解释。通常，判定某字符是否为转义字符由上下文确定。转义字符即标志着转义序列开始的那个字符。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gupqct6pe9j612x040aam02.jpg" alt="image-20210922213332770"></p><p>转义序列通常有两种功能</p><ol><li>功能是编码无法用字母表直接表示的特殊数据</li><li>用于表示无法直接键盘录入的字符(如回车符)</li></ol><p>下面是一些常见的转义字符以及它们的含义</p><table><thead><tr><th>转义字符</th><th>意义</th><th>ASCII码值(十进制)</th></tr></thead><tbody><tr><td>\n</td><td>换行(LF)，将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR)，将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT) (跳到下一个TAB位置)</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\\</td><td>代表一个反斜线字符\</td><td>092</td></tr><tr><td>\‘</td><td>代表一个单引号(撇号)字符</td><td>039</td></tr><tr><td>\“</td><td>代表一个双引号字符</td><td>034</td></tr></tbody></table><h4 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a>字符串转义</h4><p>字符串转义：输入字符串到字符串文本的过程</p><h4 id="正则转义"><a href="#正则转义" class="headerlink" title="正则转义"></a>正则转义</h4><p>正则文字到正则表达式的过程</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtunc1jkkrj6130096glv02.jpg" alt="image-20210827001634487"></p><p>如上图所示，\\\\从输入字符串到正则表达式，其实有两步转换过程，分别是字符串转义和正则转义,四个反斜杠\\\,经过第一步字符串转义，它代表的含义是两个反斜杠;这两个反斜杠再经过第二步正则转义，它就可以代表单个反斜杠\了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const str = &#x27;\\n\n\\&#x27;</span><br><span class="line">const sources = [&#x27;\n&#x27;, &#x27;\\n&#x27;, &#x27;\\\n&#x27;, &#x27;\\\\n&#x27;]</span><br><span class="line">const regs = []</span><br><span class="line"></span><br><span class="line">sources.forEach(s =&gt; regs.push(new RegExp(s, &#x27;g&#x27;)))</span><br><span class="line">regs.forEach(reg =&gt; &#123;</span><br><span class="line">  console.log(&#x27;[current reg] &#x27;, reg)</span><br><span class="line">  let once_match = reg.exec(str)</span><br><span class="line">  console.log(&#x27;[result]&#x27;, once_match)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在js中的执行结果</p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gtuna2hkc5j60eo03uaak02.jpg" alt="image-20210827001438104"  /><ol><li>‘\n’    字符串转义\n(换行符) ,匹配’\\n\n\\‘到一个换行符</li><li>‘\\n’   字符串转义’\n’(\和n) , 正则转义\n(换行符) ,匹配’\\n\n\\‘到一个换行符</li><li>‘\\\n’  字符串转义’\&#39; \n(\和换行符), 正则转义\n(换行符),匹配’\\n\n\\‘到一个换行符</li><li>‘\\\\n’ 字符串转义’\\n’，正则转义’\n’(字符\和n), 匹配’\\n\n\\‘到一个换行符</li></ol><p><strong>使用编程语言中的函数消除元字符特殊含义</strong></p><ul><li>Python re.escape(text)</li><li>Go regexp.QuoteMeta(text)</li><li>Pattern.quote(text)</li><li>PHP greg_quote(text)</li></ul><p>js 将正则文本和正则表达式转换为其他编码,虽能匹配但是是其他编码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reg1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;\\&#x27;</span>),<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> template1 = <span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;abb\\bb\\aa&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log([...template1.matchAll(reg1)])</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gupshsn6q6j60x4040mxp02.jpg" alt="image-20210922224736203"></p><h3 id="正则有哪些常见的流派及其特性"><a href="#正则有哪些常见的流派及其特性" class="headerlink" title="正则有哪些常见的流派及其特性"></a>正则有哪些常见的流派及其特性</h3><h4 id="POSIX流派"><a href="#POSIX流派" class="headerlink" title="POSIX流派"></a>POSIX流派</h4><p>定义了正则表达式的两种标准</p><ul><li><strong>BRE标准</strong>(Basic Regular Expression) 基本正则表达式</li><li><strong>ERE标准</strong>(Extended Regular Expression 扩展正则表达式)</li></ul><p>早期 BRE 与 ERE 标准的区别主要在于，BRE 标准不支持量词问号和加号，也不支持多选分支结构管道符。BRE 标准在使用花括号，圆括号时要转义才能表示特殊含义。BRE 标准用起来这么不爽，于是有了 ERE 标准，在使用花括号，圆括号时不需要转义了，还支持了问号、加号 和 多选分支。我们现在使用的 Linux 发行版，大多都集成了 GNU 套件。GNU 在实现 POSIX 标准时，做了一定的扩展，主要有以下三点扩展。GNU BRE 支持了 +、?，但转义了才表示特殊含义，即需要用+、?表示。GNU BRE 支持管道符多选分支结构，同样需要转义，即用 |表示。GNU ERE 也支持使用反引用，和 BRE 一样，使用 \1、\2…\9 表示。BRE 标准和 ERE 标准的详细区别，我给了你一个参考图，你可以看一下，浅黄色背景是 BRE 和 ERE 不同的地方，三处天蓝色字体是 GNU 扩展。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gupsrccstoj60gs094dgc02.jpg" alt="image-20210922225647356"></p><p><strong>POSIX字符组</strong></p><p>POSIX 流派还有一个特殊的地方，就是有自己的字符组，叫 POSIX 字符组。这个类似于我们之前学习的 \d 表示数字，\s 表示空白符等，POSIX 中也定义了一系列的字符组。具体的清单和解释如下所示：</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gupss3v7pdj60g30d9aav02.jpg" alt="image-20210922225731447"></p><h4 id="PCRE流派"><a href="#PCRE流派" class="headerlink" title="PCRE流派"></a>PCRE流派</h4><p>除了 POSIX 标准外，还有一个 Perl 分支，也就是我们现在熟知的 PCRE。随着 Perl 语言的发展，Perl 语言中的正则表达式功能越来越强悍，为了把 Perl 语言中正则的功能移植到其他语言中，PCRE 就诞生了。目前大部分常用编程语言都是源于 PCRE 标准，这个流派显著特征是有\d、\w、\s 这类字符组简记方式。</p><p><strong>PCRE流派的兼容问题</strong></p><p>虽然 PCRE 流派是与 Perl 正则表达式相兼容的流派，但这种兼容在各种语言和工具中还存在程度上的差别，这包括了直接兼容与间接兼容两种情况。而且，即便是直接兼容，也并非完全兼容，还是存在部分不兼容的情况。原因也很简单，Perl 语言中的正则表达式在不断改进和升级之中，其他语言和工具不可能完全做到实时跟进与更新。</p><ul><li>直接兼容, PCRE 流派中与 Perl 正则表达式直接兼容的语言或工具。比如 Perl、PHP preg、PCRE 库等，一般称之为 Perl 系。</li><li>间接兼容，比如 Java 系（包括 Java、Groovy、Scala 等）、Python 系（包括 Python2 和 Python3）、JavaScript 系（包括原生 JavaScript 和扩展库 XRegExp）、.Net 系（包括 C#、VB.Net 等）等。</li></ul><p><strong>在Linux中使用正则</strong></p><p>在遵循 POSIX 规范的 UNIX/LINUX 系统上，按照 BRE 标准 实现的有 grep、sed 和 vi/vim 等，而按照 ERE 标准 实现的有 egrep、awk 等。</p><p><strong>PCRE 流派与 POSIX 流派的对比</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gupt1qh20kj60j50b9gm502.jpg" alt="image-20210922230646487"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用 ERE 标准</span><br><span class="line">grep -E &#x27;[[:digit:]]+&#x27; access.log</span><br><span class="line"></span><br><span class="line">使用 PCRE 标准</span><br><span class="line">grep -P &#x27;\d+&#x27; access.log</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="正则处理Unicode"><a href="#正则处理Unicode" class="headerlink" title="正则处理Unicode"></a>正则处理Unicode</h3><p>​    </p><h4 id="Unicode基础知识"><a href="#Unicode基础知识" class="headerlink" title="Unicode基础知识"></a>Unicode基础知识</h4><p>Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字进行了整理、编码。Unicode 使计算机呈现和处理文字变得简单。</p><p>现在的 Unicode 字符分为 17 组编排，每组为一个平面（Plane），而每个平面拥有 65536（即 2 的 16 次方）个码值（Code Point）。然而，目前 Unicode 只用了少数平面，我们用到的绝大多数字符都属于第 0 号平面，即 BMP 平面。除了 BMP 平面之外，其它的平面都被称为补充平面。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guptmnvi8yj61c30j0gqa02.jpg" alt="image-20210922232653128"></p><p>Unicode 相当于规定了字符对应的码值，这个码值得编码成字节的形式去传输和存储。最常见的编码方式是 UTF-8，另外还有 UTF-16，UTF-32 等。UTF-8 之所以能够流行起来，是因为其编码比较巧妙，采用的是变长的方法。也就是一个 Unicode 字符，在使用 UTF-8 编码表示时占用 1 到 4 个字节不等。最重要的是 Unicode 兼容 ASCII 编码，在表示纯英文时，并不会占用更多存储空间。而汉字呢，在 UTF-8 中，通常是用三个字节来表示。</p><h3 id="如何理解正则的匹配原理以及优化原则"><a href="#如何理解正则的匹配原理以及优化原则" class="headerlink" title="如何理解正则的匹配原理以及优化原则"></a>如何理解正则的匹配原理以及优化原则</h3><h4 id="有穷状态自动机"><a href="#有穷状态自动机" class="headerlink" title="有穷状态自动机"></a>有穷状态自动机</h4><p>正则之所以能够处理复杂文本，就是因为采用了有穷状态自动机（finite automaton）。那什么是有穷自动机呢？有穷状态是指一个系统具有有穷个状态，不同的状态代表不同的意义。自动机是指系统可以根据相应的条件，在不同的状态下进行转移。从一个初始状态，根据对应的操作（比如录入的字符集）执行状态转移，最终达到终止状态（可能有一到多个终止状态）。有穷自动机的具体实现称为正则引擎，主要有 DFA 和 NFA 两种，其中 NFA 又分为传统的 NFA 和 POSIX NFA。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guomw61kmcj60g405nmxd02.jpg" alt="image-20210921224812714"></p><ul><li>确定型与非确定型，在没有编写正则表达式之前，就可以直接确定字符匹配顺序的就是确定型，不能确定字符匹配顺序的则为非确定型</li><li>有穷: 有穷即表示有限的意思，有限次数能得到结果</li><li>自动机: 自动机便是自动完成，在我们设置好匹配规则后由引擎自动完成。</li></ul><p> <strong>NFA</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guomysvwpfj60h2049dfu02.jpg" alt="image-20210921225047806"></p><p>在状态 s3 时，不需要输入任何字符，状态也有可能转换成 s1。你可以理解成 a(bb)+a 在匹配了字符 abb 之后，到底在 s3 状态，还是在 s1 状态，这是不确定的。这种状态机就是非确定性有穷状态自动机（Non-deterministic finite automaton 简称 NFA）。</p><p><strong>DFA</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guon29bwt6j60i505maa302.jpg" alt="image-20210921225406729"></p><p>NFA 和 DFA 是可以相互转化的，当我们把上面的状态表示成下面这样，就是一台 DFA 状态机了，因为在 s0-s4 这几个状态，每个状态都需要特定的输入，才能发生状态变化。</p><p><strong>POSIX NFA</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guqzkmbsbrj60fj08owem02.jpg" alt="image-20210923233802835"></p><p>如上图所示使用，使用正则 pos|posix 在文本 posix 中进行匹配，传统的 NFA 从文本中找到的是 pos，而不是 posix，而 POSIX NFA 找到的是 posix。POSIX NFA 引擎与传统的 NFA 引擎类似，但不同之处在于，POSIX NFA 在找到可能的最长匹配之前会继续回溯，也就是说它会尽可能找最长的，如果分支一样长，以最左边的为准（“The Longest-Leftmost”）</p><h4 id="NFA工作机制"><a href="#NFA工作机制" class="headerlink" title="NFA工作机制"></a><strong>NFA工作机制</strong></h4><p>NFA 是以正则为主导，反复测试字符串，这样字符串中同一部分，有可能被反复测试很多次</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">text: We study hdreact</span><br><span class="line">regex: hd(vue|react|regex)</span><br></pre></td></tr></table></figure><p>NFA 引擎的工作方式是，先看正则，再看文本，而且以正则为主导。正则中的第一个字符是 h，NFA 引擎在字符串中查找 h，接着匹配其后是否为 d。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text: We study hdreact</span><br><span class="line">                  ^</span><br><span class="line"></span><br><span class="line">regex: hd(vue|react|regex)</span><br><span class="line">          ^</span><br></pre></td></tr></table></figure><p>再根据正则看文本后面的是不是v,发现不是，此时vue分支淘汰，</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text: We study hdreact</span><br><span class="line">                  <span class="built_in">^</span></span><br><span class="line"></span><br><span class="line">regex: hd(vue|react|regex)</span><br><span class="line">          <span class="built_in">^</span>        </span><br></pre></td></tr></table></figure><p>接着看第二个分支，发现匹配上了。整个文本匹配完毕，也就不会去看后面的regex分支了。如果正则表达式改成hd(vue|regex|react)</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text: We study hdreact</span><br><span class="line">                  <span class="built_in">^</span></span><br><span class="line">regex: hd(vue|regex|react)</span><br><span class="line">  <span class="built_in">^</span></span><br></pre></td></tr></table></figure><p>当正则regex中g匹配不上react中a的时候会接着用第三个分支react来匹配,并且重新从r开始</p><p><strong>特点</strong></p><ol><li>正则表达式主导: 按照表达式的一部分执行，如果不匹配换其他部分继续匹配，直到表达式匹配完成</li><li>会发生回溯，字符串中同一部分可能会对比很多次</li><li>支持子组和反向引用</li></ol><h4 id="DFA工作机制"><a href="#DFA工作机制" class="headerlink" title="DFA工作机制"></a><strong>DFA工作机制</strong></h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text: We study hdreact</span><br><span class="line"></span><br><span class="line">regex: hd(vue|react|regex)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>DFA 会先看文本，再看正则表达式，是以文本为主导的。在具体匹配过程中，DFA 会从 We 中的 w 开始依次查找 h，定位到 h ，这个字符后面是 d。所以我们接着看正则部分是否有 d ，如果正则后面是个 d ，d后面的是r，DFA接着看正则表达式部分，此时zhushou分支被淘汰，开头是r的react regex符合要求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">text: We study hdreact</span><br><span class="line"></span><br><span class="line">regex: hd(vue|react|regex)</span><br><span class="line">^^^</span><br><span class="line"> 淘汰 符合符合</span><br></pre></td></tr></table></figure><p>继续看后面的字符串e和正则比较，符合要求，然后看a ，淘汰regex分支，react分支符合要求。接着看act，和正则比较符合要求。匹配成功。</p><p><strong>特点</strong></p><ol><li>文本主导: 按照文本的顺序执行。</li><li>记录当前有效的所有可能: 当执行(zhushou|shijian|shixi)时，同时比较zhushou shijian shixi 时需要更多的内存</li><li>每个字符只检查一次: 提高了执行效率</li><li>不能使用反向引用，捕获子组等功能</li><li>无法回溯</li></ol><p>兼容性</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1guooynsuytj60hb071jrq02.jpg" alt="image-20210921235951589"></p><p>优化原则</p><ul><li>提前编译好正则</li><li>提取出公共部分</li><li>尽量准确地表示范围</li><li>必要时才使用子组等</li><li>测试正则性能，使用ipython或regex101等</li><li>出现可能性大的放左边</li><li>避免不同分支重复匹配</li></ul><h3 id="正则网站or软件"><a href="#正则网站or软件" class="headerlink" title="正则网站or软件"></a>正则网站or软件</h3><ol><li> <a href="https://regex101.com/">https://regex101.com/</a> </li><li> <a href="https://tool.oschina.net/regex/">https://tool.oschina.net/regex/</a></li><li> <a href="http://tool.chinaz.com/regex/">http://tool.chinaz.com/regex/</a></li><li> <a href="https://www.w3cschool.cn/tools/index?name=re">https://www.w3cschool.cn/tools/index?name=re</a></li><li> <a href="https://c.runoob.com/front-end/854">https://c.runoob.com/front-end/854</a></li><li> <a href="http://tools.haokh.net/Regex">http://tools.haokh.net/Regex</a></li><li> Windows 上推荐：RegexBuddy</li><li> Mac上推荐：Expressions</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;在编程语言中，正则常常用来简化文本处理的逻辑。在 Linux 命令中，它也可以帮助我们轻松地查找或编辑文件的内容，甚至实现整个文件夹中所有文</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://example.com/2021/08/25/index/"/>
    <id>http://example.com/2021/08/25/index/</id>
    <published>2021-08-25T15:36:11.000Z</published>
    <updated>2021-11-08T16:15:04.548Z</updated>
    
    <content type="html"><![CDATA[<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><a class="btn-beautify button--animated larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated blue larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated pink larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated red larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated purple larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated orange larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><a class="btn-beautify button--animated green larger" href="https://butterfly.js.org/"   title="Butterfly"><i class="far fa-hand-point-right"></i><span>Butterfly</span></a><div class="note flat"><p>默認 提示塊標籤</p></div><div class="note default flat"><p>default 提示塊標籤</p></div><div class="note primary flat"><p>primary 提示塊標籤</p></div><div class="note success flat"><p>success 提示塊標籤</p></div><div class="note info flat"><p>info 提示塊標籤</p></div><div class="note warning flat"><p>warning 提示塊標籤</p></div><div class="note danger flat"><p>danger 提示塊標籤</p></div><div class="mermaid">pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5</div>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;tabs&quot; id=&quot;test1&quot;&gt;&lt;ul class=&quot;nav-tabs&quot;&gt;&lt;li class=&quot;tab active&quot;&gt;&lt;button type=&quot;button&quot; data-href=&quot;#test1-1&quot;&gt;test1 1&lt;/button&gt;&lt;/li&gt;&lt;li</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>你不了解的js</title>
    <link href="http://example.com/2021/08/20/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/"/>
    <id>http://example.com/2021/08/20/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js/</id>
    <published>2021-08-20T00:00:00.000Z</published>
    <updated>2021-11-08T16:15:04.548Z</updated>
    
    <content type="html"><![CDATA[<p>使用 test</p><h3 id="主题一"><a href="#主题一" class="headerlink" title="主题一"></a>主题一</h3><p>主题一内容</p><h3 id="主题二"><a href="#主题二" class="headerlink" title="主题二"></a>主题二</h3><p>主题二内容</p><h3 id="主题三"><a href="#主题三" class="headerlink" title="主题三"></a>主题三</h3><p>主题三内容</p><h3 id="主题四"><a href="#主题四" class="headerlink" title="主题四"></a>主题四</h3><p>主题四内容</p><h3 id="主题五"><a href="#主题五" class="headerlink" title="主题五"></a>主题五</h3><p>主题五内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用 test&lt;/p&gt;
&lt;h3 id=&quot;主题一&quot;&gt;&lt;a href=&quot;#主题一&quot; class=&quot;headerlink&quot; title=&quot;主题一&quot;&gt;&lt;/a&gt;主题一&lt;/h3&gt;&lt;p&gt;主题一内容&lt;/p&gt;
&lt;h3 id=&quot;主题二&quot;&gt;&lt;a href=&quot;#主题二&quot; class=&quot;header</summary>
      
    
    
    
    
  </entry>
  
</feed>
